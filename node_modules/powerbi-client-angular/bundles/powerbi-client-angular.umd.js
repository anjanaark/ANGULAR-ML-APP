(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('powerbi-client')) :
    typeof define === 'function' && define.amd ? define('powerbi-client-angular', ['exports', '@angular/core', 'powerbi-client'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['powerbi-client-angular'] = {}, global.ng.core, global['powerbi-client']));
}(this, (function (exports, core, powerbiClient) { 'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function () { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }
    function __classPrivateFieldIn(state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function"))
            throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    /**
     * Get JSON string representation of the given map.
     *
     * @param map Map of event and corresponding handler method
     *
     */
    var stringifyMap = function (map) {
        // Return empty string for empty/null map
        if (!map) {
            return '';
        }
        // Get entries of map as array
        var mapEntries = Array.from(map);
        // Return JSON string
        return JSON.stringify(mapEntries.map(function (mapEntry) {
            // Convert event handler method to a string containing its source code for comparison
            return [mapEntry[0], mapEntry[1] ? mapEntry[1].toString() : ''];
        }));
    };
    // SDK information to be used with service instance
    var sdkType = 'powerbi-client-angular';
    var sdkWrapperVersion = '2.0.1';

    // Copyright (c) Microsoft Corporation.
    /**
     * Base component to hold common properties for all the Power BI entities
     */
    var PowerBIEmbedComponent = /** @class */ (function () {
        function PowerBIEmbedComponent() {
            // JSON stringify of prev event handler map
            this.prevEventHandlerMapString = '';
        }
        PowerBIEmbedComponent.prototype.ngOnInit = function () {
            // Initialize powerbi variable for child component
            if (this.service) {
                this.powerbi = this.service;
            }
            else {
                this.powerbi = new powerbiClient.service.Service(powerbiClient.factories.hpmFactory, powerbiClient.factories.wpmpFactory, powerbiClient.factories.routerFactory);
            }
            this.powerbi.setSdkInfo(sdkType, sdkWrapperVersion);
        };
        /**
         * Sets all event handlers from the input on the embedded entity
         *
         * @param embed Embedded object
         * @param eventHandlerMap Array of event handlers to be set on embedded entity
         * @returns void
         */
        PowerBIEmbedComponent.prototype.setEventHandlers = function (embed, eventHandlerMap) {
            // Get string representation of eventHandlerMap
            var eventHandlerMapString = stringifyMap(eventHandlerMap);
            // Check if event handler map changed
            if (this.prevEventHandlerMapString === eventHandlerMapString) {
                return;
            }
            // Update prev string representation of event handler map
            this.prevEventHandlerMapString = eventHandlerMapString;
            // Apply all provided event handlers
            eventHandlerMap.forEach(function (eventHandlerMethod, eventName) {
                // Removes event handler for this event
                embed.off(eventName);
                // Event handler is effectively removed for this event when eventHandlerMethod is null
                if (eventHandlerMethod) {
                    // Set single event handler
                    embed.on(eventName, function (event) {
                        eventHandlerMethod(event, embed);
                    });
                }
            });
        };
        return PowerBIEmbedComponent;
    }());
    PowerBIEmbedComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'powerbi-embed',
                    template: ''
                },] }
    ];
    PowerBIEmbedComponent.propDecorators = {
        cssClassName: [{ type: core.Input }],
        service: [{ type: core.Input }]
    };

    /**
     * Report component to embed the report, extends the Base Component
     */
    var PowerBIReportEmbedComponent = /** @class */ (function (_super) {
        __extends(PowerBIReportEmbedComponent, _super);
        function PowerBIReportEmbedComponent() {
            var _this = _super.call(this) || this;
            // Phased embedding flag (Optional)
            _this.phasedEmbedding = false;
            return _this;
        }
        Object.defineProperty(PowerBIReportEmbedComponent.prototype, "embed", {
            // Getter for this._embed
            get: function () {
                return this._embed;
            },
            // Setter for this._embed
            set: function (newEmbedInstance) {
                this._embed = newEmbedInstance;
            },
            enumerable: false,
            configurable: true
        });
        // Returns embed object to calling function
        PowerBIReportEmbedComponent.prototype.getReport = function () {
            return this._embed;
        };
        PowerBIReportEmbedComponent.prototype.ngOnInit = function () {
            // Initialize PowerBI service instance variable from parent
            _super.prototype.ngOnInit.call(this);
        };
        PowerBIReportEmbedComponent.prototype.ngOnChanges = function (changes) {
            if (changes.embedConfig) {
                var prevEmbedConfig = changes.embedConfig.previousValue;
                // Check if the function is being called for the first time
                if (!prevEmbedConfig) {
                    return;
                }
                // Input from parent get updated, thus call embedOrUpdateReport function
                this.embedOrUpdateReport(prevEmbedConfig);
            }
            // Set event handlers if available
            if (this.eventHandlers && this.embed) {
                _super.prototype.setEventHandlers.call(this, this.embed, this.eventHandlers);
            }
        };
        PowerBIReportEmbedComponent.prototype.ngAfterViewInit = function () {
            // Check if container exists on the UI
            if (this.containerRef.nativeElement) {
                // Decide to embed, load or bootstrap
                if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                    this.embedReport();
                }
                else {
                    this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
                }
            }
            // Set event handlers if available
            if (this.eventHandlers && this.embed) {
                _super.prototype.setEventHandlers.call(this, this.embed, this.eventHandlers);
            }
        };
        /**
         * Embed or load the PowerBI Report based on phasedEmbedding flag
         *
         * @returns void
         */
        PowerBIReportEmbedComponent.prototype.embedReport = function () {
            // Check if the HTML container is rendered and available
            if (!this.containerRef.nativeElement) {
                return;
            }
            // Load when phasedEmbedding flag is true, embed otherwise
            if (this.phasedEmbedding) {
                this.embed = this.powerbi.load(this.containerRef.nativeElement, this.embedConfig);
            }
            else {
                this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
            }
        };
        /**
         * When component updates, choose to _embed_ or _load_ the powerbi report
         * or do nothing if the embedUrl and accessToken did not update in the new properties
         *
         * @param prevEmbedConfig IReportEmbedConfiguration
         * @returns void
         */
        PowerBIReportEmbedComponent.prototype.embedOrUpdateReport = function (prevEmbedConfig) {
            // Check if Embed URL and Access Token are present in current properties
            if (!this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
                return;
            }
            // Embed or load in the following scenario
            // Embed URL is updated (E.g. New report is to be embedded)
            if (this.containerRef.nativeElement && this.embedConfig.embedUrl !== prevEmbedConfig.embedUrl) {
                this.embedReport();
            }
        };
        return PowerBIReportEmbedComponent;
    }(PowerBIEmbedComponent));
    PowerBIReportEmbedComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'powerbi-report[embedConfig]',
                    template: '<div class={{cssClassName}} #reportContainer></div>'
                },] }
    ];
    PowerBIReportEmbedComponent.ctorParameters = function () { return []; };
    PowerBIReportEmbedComponent.propDecorators = {
        embedConfig: [{ type: core.Input }],
        phasedEmbedding: [{ type: core.Input }],
        eventHandlers: [{ type: core.Input }],
        containerRef: [{ type: core.ViewChild, args: ['reportContainer',] }]
    };

    /**
     * Dashboard component to embed the dashboard, extends the Base component
     */
    var PowerBIDashboardEmbedComponent = /** @class */ (function (_super) {
        __extends(PowerBIDashboardEmbedComponent, _super);
        function PowerBIDashboardEmbedComponent() {
            return _super.call(this) || this;
        }
        Object.defineProperty(PowerBIDashboardEmbedComponent.prototype, "embed", {
            // Getter for this._embed
            get: function () {
                return this._embed;
            },
            // Setter for this._embed
            set: function (newEmbedInstance) {
                this._embed = newEmbedInstance;
            },
            enumerable: false,
            configurable: true
        });
        // Returns embed object to calling function
        PowerBIDashboardEmbedComponent.prototype.getDashboard = function () {
            return this.embed;
        };
        PowerBIDashboardEmbedComponent.prototype.ngOnInit = function () {
            // Initialize PowerBI service instance variable from parent
            _super.prototype.ngOnInit.call(this);
        };
        PowerBIDashboardEmbedComponent.prototype.ngOnChanges = function (changes) {
            if (changes.embedConfig) {
                var prevEmbedConfig = changes.embedConfig.previousValue;
                // Check if the function is being called for the first time
                if (!prevEmbedConfig) {
                    return;
                }
                // Input from parent get updated, thus call embedOrUpdateDashboard function
                this.embedOrUpdateDashboard(prevEmbedConfig);
            }
            // Set event handlers if available
            if (this.eventHandlers && this.embed) {
                _super.prototype.setEventHandlers.call(this, this.embed, this.eventHandlers);
            }
        };
        PowerBIDashboardEmbedComponent.prototype.ngAfterViewInit = function () {
            // Check if container exists on the UI
            if (this.containerRef.nativeElement) {
                // Decide to embed or bootstrap
                if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                    this.embedDashboard();
                }
                else {
                    this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
                }
            }
            // Set event handlers if available
            if (this.eventHandlers && this.embed) {
                _super.prototype.setEventHandlers.call(this, this.embed, this.eventHandlers);
            }
        };
        /**
         * Embed the PowerBI Dashboard
         *
         * @returns void
         */
        PowerBIDashboardEmbedComponent.prototype.embedDashboard = function () {
            // Check if the HTML container is rendered and available
            if (!this.containerRef.nativeElement) {
                return;
            }
            this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
        };
        /**
         * When component updates, choose to _embed_ the powerbi dashboard
         * or do nothing if the embedUrl and accessToken did not update in the new properties
         *
         * @param prevEmbedConfig IDashboardEmbedConfiguration
         * @returns void
         */
        PowerBIDashboardEmbedComponent.prototype.embedOrUpdateDashboard = function (prevEmbedConfig) {
            // Check if Embed URL and Access Token are present in current properties
            if (!this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
                return;
            }
            // Embed in the following scenario
            // Embed URL is updated (E.g. New dashboard is to be embedded)
            if (this.containerRef.nativeElement && this.embedConfig.embedUrl !== prevEmbedConfig.embedUrl) {
                this.embedDashboard();
            }
        };
        return PowerBIDashboardEmbedComponent;
    }(PowerBIEmbedComponent));
    PowerBIDashboardEmbedComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'powerbi-dashboard[embedConfig]',
                    template: '<div class={{cssClassName}} #dashboardContainer></div>'
                },] }
    ];
    PowerBIDashboardEmbedComponent.ctorParameters = function () { return []; };
    PowerBIDashboardEmbedComponent.propDecorators = {
        embedConfig: [{ type: core.Input }],
        eventHandlers: [{ type: core.Input }],
        containerRef: [{ type: core.ViewChild, args: ['dashboardContainer',] }]
    };

    /**
     * Tile component to embed the tile, extends Base component
     */
    var PowerBITileEmbedComponent = /** @class */ (function (_super) {
        __extends(PowerBITileEmbedComponent, _super);
        function PowerBITileEmbedComponent() {
            return _super.call(this) || this;
        }
        Object.defineProperty(PowerBITileEmbedComponent.prototype, "embed", {
            // Getter for this._embed
            get: function () {
                return this._embed;
            },
            // Setter for this._embed
            set: function (newEmbedInstance) {
                this._embed = newEmbedInstance;
            },
            enumerable: false,
            configurable: true
        });
        // Returns embed object to calling function
        PowerBITileEmbedComponent.prototype.getTile = function () {
            return this._embed;
        };
        PowerBITileEmbedComponent.prototype.ngOnInit = function () {
            // Initialize PowerBI service instance variable from parent
            _super.prototype.ngOnInit.call(this);
        };
        PowerBITileEmbedComponent.prototype.ngOnChanges = function (changes) {
            if (changes.embedConfig) {
                var prevEmbedConfig = changes.embedConfig.previousValue;
                // Check if the function is being called for the first time
                if (!prevEmbedConfig) {
                    return;
                }
                // Input from parent get updated, thus call embedOrUpdateDashboard function
                this.embedOrUpdateTile(prevEmbedConfig);
            }
            // Set event handlers if available
            if (this.eventHandlers && this.embed) {
                _super.prototype.setEventHandlers.call(this, this.embed, this.eventHandlers);
            }
        };
        PowerBITileEmbedComponent.prototype.ngAfterViewInit = function () {
            // Check if container exists on the UI
            if (this.containerRef.nativeElement) {
                // Decide to embed or bootstrap
                if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                    this.embedTile();
                }
                else {
                    this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
                }
            }
            // Set event handlers if available
            if (this.eventHandlers && this.embed) {
                _super.prototype.setEventHandlers.call(this, this.embed, this.eventHandlers);
            }
        };
        /**
         * Embed the PowerBI Tile
         *
         * @returns void
         */
        PowerBITileEmbedComponent.prototype.embedTile = function () {
            // Check if the HTML container is rendered and available
            if (!this.containerRef.nativeElement) {
                return;
            }
            this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
        };
        /**
         * When component updates, choose to _embed_ the powerbi tile
         * or do nothing if the embedUrl and accessToken did not update in the new properties
         *
         * @param prevEmbedConfig ITileEmbedConfiguration
         * @returns void
         */
        PowerBITileEmbedComponent.prototype.embedOrUpdateTile = function (prevEmbedConfig) {
            // Check if Embed URL and Access Token are present in current properties
            if (!this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
                return;
            }
            // Embed in the following scenario
            // Embed URL is updated (E.g. New tile is to be embedded)
            if (this.containerRef.nativeElement && this.embedConfig.embedUrl !== prevEmbedConfig.embedUrl) {
                this.embedTile();
            }
        };
        return PowerBITileEmbedComponent;
    }(PowerBIEmbedComponent));
    PowerBITileEmbedComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'powerbi-tile[embedConfig]',
                    template: '<div class={{cssClassName}} #tileContainer></div>'
                },] }
    ];
    PowerBITileEmbedComponent.ctorParameters = function () { return []; };
    PowerBITileEmbedComponent.propDecorators = {
        embedConfig: [{ type: core.Input }],
        eventHandlers: [{ type: core.Input }],
        containerRef: [{ type: core.ViewChild, args: ['tileContainer',] }]
    };

    /**
     * Paginated report component to embed the entity, extends the Base component
     */
    var PowerBIPaginatedReportEmbedComponent = /** @class */ (function (_super) {
        __extends(PowerBIPaginatedReportEmbedComponent, _super);
        function PowerBIPaginatedReportEmbedComponent() {
            return _super.call(this) || this;
        }
        Object.defineProperty(PowerBIPaginatedReportEmbedComponent.prototype, "embed", {
            // Getter for this._embed
            get: function () {
                return this._embed;
            },
            // Setter for this._embed
            set: function (newEmbedInstance) {
                this._embed = newEmbedInstance;
            },
            enumerable: false,
            configurable: true
        });
        PowerBIPaginatedReportEmbedComponent.prototype.ngOnInit = function () {
            // Initialize PowerBI service instance variable from parent
            _super.prototype.ngOnInit.call(this);
        };
        PowerBIPaginatedReportEmbedComponent.prototype.ngOnChanges = function (changes) {
            if (changes.embedConfig) {
                var prevEmbedConfig = changes.embedConfig.previousValue;
                // Check if the function is being called for the first time
                if (!prevEmbedConfig) {
                    return;
                }
                // Input from parent get updated, thus call embedOrUpdateDashboard function
                this.embedOrUpdatedPaginatedReport(prevEmbedConfig);
            }
        };
        PowerBIPaginatedReportEmbedComponent.prototype.ngAfterViewInit = function () {
            // Check if container exists on the UI
            if (this.containerRef.nativeElement) {
                // Decide to embed
                this.embedPaginatedReport();
            }
        };
        /**
         * Embed the PowerBI Paginated report
         *
         * @returns void
         */
        PowerBIPaginatedReportEmbedComponent.prototype.embedPaginatedReport = function () {
            // Check if the HTML container is rendered and available
            if (!this.containerRef.nativeElement) {
                return;
            }
            // Embed paginated report
            this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
        };
        /**
         * When component updates, choose to _embed_ the powerbi paginated report
         * or do nothing if the embedUrl and accessToken did not update in the new properties
         *
         * @param prevEmbedConfig IEmbedConfiguration
         * @returns void
         */
        PowerBIPaginatedReportEmbedComponent.prototype.embedOrUpdatedPaginatedReport = function (prevEmbedConfig) {
            // Check if Embed URL and Access Token are present in current properties
            if (!this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
                return;
            }
            // Embed in the following scenario
            // Embed URL is updated (E.g. New paginated report is to be embedded)
            if (this.containerRef.nativeElement && this.embedConfig.embedUrl !== prevEmbedConfig.embedUrl) {
                this.embedPaginatedReport();
            }
        };
        return PowerBIPaginatedReportEmbedComponent;
    }(PowerBIEmbedComponent));
    PowerBIPaginatedReportEmbedComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'powerbi-paginated-report[embedConfig]',
                    template: '<div class={{cssClassName}} #paginatedReportContainer></div>'
                },] }
    ];
    PowerBIPaginatedReportEmbedComponent.ctorParameters = function () { return []; };
    PowerBIPaginatedReportEmbedComponent.propDecorators = {
        embedConfig: [{ type: core.Input }],
        containerRef: [{ type: core.ViewChild, args: ['paginatedReportContainer',] }]
    };

    /**
     * Visual component to embed the visual, extends Base component
     */
    var PowerBIVisualEmbedComponent = /** @class */ (function (_super) {
        __extends(PowerBIVisualEmbedComponent, _super);
        function PowerBIVisualEmbedComponent() {
            return _super.call(this) || this;
        }
        Object.defineProperty(PowerBIVisualEmbedComponent.prototype, "embed", {
            // Getter for this._embed
            get: function () {
                return this._embed;
            },
            // Setter for this._embed
            set: function (newEmbedInstance) {
                this._embed = newEmbedInstance;
            },
            enumerable: false,
            configurable: true
        });
        // Returns embed object to calling function
        PowerBIVisualEmbedComponent.prototype.getVisual = function () {
            return this._embed;
        };
        PowerBIVisualEmbedComponent.prototype.ngOnInit = function () {
            // Initialize PowerBI service instance variable from parent
            _super.prototype.ngOnInit.call(this);
        };
        PowerBIVisualEmbedComponent.prototype.ngOnChanges = function (changes) {
            if (changes.embedConfig) {
                var prevEmbedConfig = changes.embedConfig.previousValue;
                // Check if the function is being called for the first time
                if (!prevEmbedConfig) {
                    return;
                }
                // Input from parent get updated, thus call embedOrUpdateDashboard function
                this.embedOrUpdateVisual(prevEmbedConfig);
            }
            // Set event handlers if available
            if (this.eventHandlers && this.embed) {
                _super.prototype.setEventHandlers.call(this, this.embed, this.eventHandlers);
            }
        };
        PowerBIVisualEmbedComponent.prototype.ngAfterViewInit = function () {
            // Check if container exists on the UI
            if (this.containerRef.nativeElement) {
                // Decide to embed or bootstrap
                if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                    this.embedVisual();
                }
                else {
                    this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
                }
            }
            // Set event handlers if available
            if (this.eventHandlers && this.embed) {
                _super.prototype.setEventHandlers.call(this, this.embed, this.eventHandlers);
            }
        };
        /**
         * Embed the PowerBI Visual
         *
         * @returns void
         */
        PowerBIVisualEmbedComponent.prototype.embedVisual = function () {
            // Check if the HTML container is rendered and available
            if (!this.containerRef.nativeElement) {
                return;
            }
            this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
        };
        /**
         * When component updates, choose to _embed_ the powerbi visual
         * or do nothing if the embedUrl and accessToken did not update in the new properties
         *
         * @param prevEmbedConfig IVisualEmbedConfiguration
         * @returns void
         */
        PowerBIVisualEmbedComponent.prototype.embedOrUpdateVisual = function (prevEmbedConfig) {
            // Check if Embed URL and Access Token are present in current properties
            if (!this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
                return;
            }
            // Embed in the following scenario
            // Embed URL is updated (E.g. New visual is to be embedded)
            if (this.containerRef.nativeElement && this.embedConfig.embedUrl !== prevEmbedConfig.embedUrl) {
                this.embedVisual();
            }
        };
        return PowerBIVisualEmbedComponent;
    }(PowerBIEmbedComponent));
    PowerBIVisualEmbedComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'powerbi-visual[embedConfig]',
                    template: '<div class={{cssClassName}} #visualContainer></div>'
                },] }
    ];
    PowerBIVisualEmbedComponent.ctorParameters = function () { return []; };
    PowerBIVisualEmbedComponent.propDecorators = {
        embedConfig: [{ type: core.Input }],
        eventHandlers: [{ type: core.Input }],
        containerRef: [{ type: core.ViewChild, args: ['visualContainer',] }]
    };

    /**
     * Qna component to embed the Qna visual, extends Base component
     */
    var PowerBIQnaEmbedComponent = /** @class */ (function (_super) {
        __extends(PowerBIQnaEmbedComponent, _super);
        function PowerBIQnaEmbedComponent() {
            return _super.call(this) || this;
        }
        Object.defineProperty(PowerBIQnaEmbedComponent.prototype, "embed", {
            // Getter for this._embed
            get: function () {
                return this._embed;
            },
            // Setter for this._embed
            set: function (newEmbedInstance) {
                this._embed = newEmbedInstance;
            },
            enumerable: false,
            configurable: true
        });
        // Returns embed object to calling function
        PowerBIQnaEmbedComponent.prototype.getQna = function () {
            return this._embed;
        };
        PowerBIQnaEmbedComponent.prototype.ngOnInit = function () {
            // Initialize PowerBI service instance variable from parent
            _super.prototype.ngOnInit.call(this);
        };
        PowerBIQnaEmbedComponent.prototype.ngOnChanges = function (changes) {
            if (changes.embedConfig) {
                var prevEmbedConfig = changes.embedConfig.previousValue;
                // Check if the function is being called for the first time
                if (!prevEmbedConfig) {
                    return;
                }
                // Input from parent get updated, thus call embedOrUpdateDashboard function
                this.embedOrUpdateQna(prevEmbedConfig);
            }
            // Set event handlers if available
            if (this.eventHandlers && this.embed) {
                _super.prototype.setEventHandlers.call(this, this.embed, this.eventHandlers);
            }
        };
        PowerBIQnaEmbedComponent.prototype.ngAfterViewInit = function () {
            // Check if container exists on the UI
            if (this.containerRef.nativeElement) {
                // Decide to embed or bootstrap
                if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                    this.embedQnaVisual();
                }
                else {
                    this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
                }
            }
            // Set event handlers if available
            if (this.eventHandlers && this.embed) {
                _super.prototype.setEventHandlers.call(this, this.embed, this.eventHandlers);
            }
        };
        /**
         * Embed the PowerBI QnA Visual
         *
         * @returns void
         */
        PowerBIQnaEmbedComponent.prototype.embedQnaVisual = function () {
            // Check if the HTML container is rendered and available
            if (!this.containerRef.nativeElement) {
                return;
            }
            this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
        };
        /**
         * When component updates, choose to _embed_ the powerbi qna visual
         * or do nothing if the embedUrl and accessToken did not update in the new properties
         *
         * @param prevEmbedConfig IQnaEmbedConfiguration
         * @returns void
         */
        PowerBIQnaEmbedComponent.prototype.embedOrUpdateQna = function (prevEmbedConfig) {
            // Check if Embed URL and Access Token are present in current properties
            if (!this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
                return;
            }
            // Embed in the following scenario
            // Embed URL is updated (E.g. New Qna visual is to be embedded)
            if (this.containerRef.nativeElement && this.embedConfig.embedUrl !== prevEmbedConfig.embedUrl) {
                this.embedQnaVisual();
            }
        };
        return PowerBIQnaEmbedComponent;
    }(PowerBIEmbedComponent));
    PowerBIQnaEmbedComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'powerbi-qna[embedConfig]',
                    template: '<div class={{cssClassName}} #qnaContainer></div>'
                },] }
    ];
    PowerBIQnaEmbedComponent.ctorParameters = function () { return []; };
    PowerBIQnaEmbedComponent.propDecorators = {
        embedConfig: [{ type: core.Input }],
        eventHandlers: [{ type: core.Input }],
        containerRef: [{ type: core.ViewChild, args: ['qnaContainer',] }]
    };

    // Copyright (c) Microsoft Corporation.
    var PowerBIEmbedModule = /** @class */ (function () {
        function PowerBIEmbedModule() {
        }
        return PowerBIEmbedModule;
    }());
    PowerBIEmbedModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [
                        PowerBIEmbedComponent,
                        PowerBIDashboardEmbedComponent,
                        PowerBIPaginatedReportEmbedComponent,
                        PowerBIQnaEmbedComponent,
                        PowerBIReportEmbedComponent,
                        PowerBITileEmbedComponent,
                        PowerBIVisualEmbedComponent,
                    ],
                    imports: [],
                    exports: [
                        PowerBIDashboardEmbedComponent,
                        PowerBIPaginatedReportEmbedComponent,
                        PowerBIQnaEmbedComponent,
                        PowerBIReportEmbedComponent,
                        PowerBITileEmbedComponent,
                        PowerBIVisualEmbedComponent,
                    ],
                },] }
    ];

    // Copyright (c) Microsoft Corporation.

    /**
     * Generated bundle index. Do not edit.
     */

    exports.PowerBIDashboardEmbedComponent = PowerBIDashboardEmbedComponent;
    exports.PowerBIEmbedModule = PowerBIEmbedModule;
    exports.PowerBIPaginatedReportEmbedComponent = PowerBIPaginatedReportEmbedComponent;
    exports.PowerBIQnaEmbedComponent = PowerBIQnaEmbedComponent;
    exports.PowerBIReportEmbedComponent = PowerBIReportEmbedComponent;
    exports.PowerBITileEmbedComponent = PowerBITileEmbedComponent;
    exports.PowerBIVisualEmbedComponent = PowerBIVisualEmbedComponent;
    exports.ɵa = PowerBIEmbedComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=powerbi-client-angular.umd.js.map
