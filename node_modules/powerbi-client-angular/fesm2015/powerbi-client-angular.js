import { Component, Input, ViewChild, NgModule } from '@angular/core';
import { service, factories } from 'powerbi-client';

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Get JSON string representation of the given map.
 *
 * @param map Map of event and corresponding handler method
 *
 */
const stringifyMap = (map) => {
    // Return empty string for empty/null map
    if (!map) {
        return '';
    }
    // Get entries of map as array
    const mapEntries = Array.from(map);
    // Return JSON string
    return JSON.stringify(mapEntries.map((mapEntry) => 
    // Convert event handler method to a string containing its source code for comparison
    [mapEntry[0], mapEntry[1] ? mapEntry[1].toString() : '']));
};
// SDK information to be used with service instance
const sdkType = 'powerbi-client-angular';
const sdkWrapperVersion = '2.0.1';

// Copyright (c) Microsoft Corporation.
/**
 * Base component to hold common properties for all the Power BI entities
 */
class PowerBIEmbedComponent {
    constructor() {
        // JSON stringify of prev event handler map
        this.prevEventHandlerMapString = '';
    }
    ngOnInit() {
        // Initialize powerbi variable for child component
        if (this.service) {
            this.powerbi = this.service;
        }
        else {
            this.powerbi = new service.Service(factories.hpmFactory, factories.wpmpFactory, factories.routerFactory);
        }
        this.powerbi.setSdkInfo(sdkType, sdkWrapperVersion);
    }
    /**
     * Sets all event handlers from the input on the embedded entity
     *
     * @param embed Embedded object
     * @param eventHandlerMap Array of event handlers to be set on embedded entity
     * @returns void
     */
    setEventHandlers(embed, eventHandlerMap) {
        // Get string representation of eventHandlerMap
        const eventHandlerMapString = stringifyMap(eventHandlerMap);
        // Check if event handler map changed
        if (this.prevEventHandlerMapString === eventHandlerMapString) {
            return;
        }
        // Update prev string representation of event handler map
        this.prevEventHandlerMapString = eventHandlerMapString;
        // Apply all provided event handlers
        eventHandlerMap.forEach((eventHandlerMethod, eventName) => {
            // Removes event handler for this event
            embed.off(eventName);
            // Event handler is effectively removed for this event when eventHandlerMethod is null
            if (eventHandlerMethod) {
                // Set single event handler
                embed.on(eventName, (event) => {
                    eventHandlerMethod(event, embed);
                });
            }
        });
    }
}
PowerBIEmbedComponent.decorators = [
    { type: Component, args: [{
                selector: 'powerbi-embed',
                template: ''
            },] }
];
PowerBIEmbedComponent.propDecorators = {
    cssClassName: [{ type: Input }],
    service: [{ type: Input }]
};

// Copyright (c) Microsoft Corporation.
/**
 * Report component to embed the report, extends the Base Component
 */
class PowerBIReportEmbedComponent extends PowerBIEmbedComponent {
    constructor() {
        super();
        // Phased embedding flag (Optional)
        this.phasedEmbedding = false;
    }
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    // Returns embed object to calling function
    getReport() {
        return this._embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            const prevEmbedConfig = changes.embedConfig.previousValue;
            // Check if the function is being called for the first time
            if (!prevEmbedConfig) {
                return;
            }
            // Input from parent get updated, thus call embedOrUpdateReport function
            this.embedOrUpdateReport(prevEmbedConfig);
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed, load or bootstrap
            if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                this.embedReport();
            }
            else {
                this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed or load the PowerBI Report based on phasedEmbedding flag
     *
     * @returns void
     */
    embedReport() {
        // Check if the HTML container is rendered and available
        if (!this.containerRef.nativeElement) {
            return;
        }
        // Load when phasedEmbedding flag is true, embed otherwise
        if (this.phasedEmbedding) {
            this.embed = this.powerbi.load(this.containerRef.nativeElement, this.embedConfig);
        }
        else {
            this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
        }
    }
    /**
     * When component updates, choose to _embed_ or _load_ the powerbi report
     * or do nothing if the embedUrl and accessToken did not update in the new properties
     *
     * @param prevEmbedConfig IReportEmbedConfiguration
     * @returns void
     */
    embedOrUpdateReport(prevEmbedConfig) {
        // Check if Embed URL and Access Token are present in current properties
        if (!this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
            return;
        }
        // Embed or load in the following scenario
        // Embed URL is updated (E.g. New report is to be embedded)
        if (this.containerRef.nativeElement && this.embedConfig.embedUrl !== prevEmbedConfig.embedUrl) {
            this.embedReport();
        }
    }
}
PowerBIReportEmbedComponent.decorators = [
    { type: Component, args: [{
                selector: 'powerbi-report[embedConfig]',
                template: '<div class={{cssClassName}} #reportContainer></div>'
            },] }
];
PowerBIReportEmbedComponent.ctorParameters = () => [];
PowerBIReportEmbedComponent.propDecorators = {
    embedConfig: [{ type: Input }],
    phasedEmbedding: [{ type: Input }],
    eventHandlers: [{ type: Input }],
    containerRef: [{ type: ViewChild, args: ['reportContainer',] }]
};

// Copyright (c) Microsoft Corporation.
/**
 * Dashboard component to embed the dashboard, extends the Base component
 */
class PowerBIDashboardEmbedComponent extends PowerBIEmbedComponent {
    constructor() {
        super();
    }
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    // Returns embed object to calling function
    getDashboard() {
        return this.embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            const prevEmbedConfig = changes.embedConfig.previousValue;
            // Check if the function is being called for the first time
            if (!prevEmbedConfig) {
                return;
            }
            // Input from parent get updated, thus call embedOrUpdateDashboard function
            this.embedOrUpdateDashboard(prevEmbedConfig);
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed or bootstrap
            if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                this.embedDashboard();
            }
            else {
                this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed the PowerBI Dashboard
     *
     * @returns void
     */
    embedDashboard() {
        // Check if the HTML container is rendered and available
        if (!this.containerRef.nativeElement) {
            return;
        }
        this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
    }
    /**
     * When component updates, choose to _embed_ the powerbi dashboard
     * or do nothing if the embedUrl and accessToken did not update in the new properties
     *
     * @param prevEmbedConfig IDashboardEmbedConfiguration
     * @returns void
     */
    embedOrUpdateDashboard(prevEmbedConfig) {
        // Check if Embed URL and Access Token are present in current properties
        if (!this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
            return;
        }
        // Embed in the following scenario
        // Embed URL is updated (E.g. New dashboard is to be embedded)
        if (this.containerRef.nativeElement && this.embedConfig.embedUrl !== prevEmbedConfig.embedUrl) {
            this.embedDashboard();
        }
    }
}
PowerBIDashboardEmbedComponent.decorators = [
    { type: Component, args: [{
                selector: 'powerbi-dashboard[embedConfig]',
                template: '<div class={{cssClassName}} #dashboardContainer></div>'
            },] }
];
PowerBIDashboardEmbedComponent.ctorParameters = () => [];
PowerBIDashboardEmbedComponent.propDecorators = {
    embedConfig: [{ type: Input }],
    eventHandlers: [{ type: Input }],
    containerRef: [{ type: ViewChild, args: ['dashboardContainer',] }]
};

// Copyright (c) Microsoft Corporation.
/**
 * Tile component to embed the tile, extends Base component
 */
class PowerBITileEmbedComponent extends PowerBIEmbedComponent {
    constructor() {
        super();
    }
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    // Returns embed object to calling function
    getTile() {
        return this._embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            const prevEmbedConfig = changes.embedConfig.previousValue;
            // Check if the function is being called for the first time
            if (!prevEmbedConfig) {
                return;
            }
            // Input from parent get updated, thus call embedOrUpdateDashboard function
            this.embedOrUpdateTile(prevEmbedConfig);
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed or bootstrap
            if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                this.embedTile();
            }
            else {
                this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed the PowerBI Tile
     *
     * @returns void
     */
    embedTile() {
        // Check if the HTML container is rendered and available
        if (!this.containerRef.nativeElement) {
            return;
        }
        this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
    }
    /**
     * When component updates, choose to _embed_ the powerbi tile
     * or do nothing if the embedUrl and accessToken did not update in the new properties
     *
     * @param prevEmbedConfig ITileEmbedConfiguration
     * @returns void
     */
    embedOrUpdateTile(prevEmbedConfig) {
        // Check if Embed URL and Access Token are present in current properties
        if (!this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
            return;
        }
        // Embed in the following scenario
        // Embed URL is updated (E.g. New tile is to be embedded)
        if (this.containerRef.nativeElement && this.embedConfig.embedUrl !== prevEmbedConfig.embedUrl) {
            this.embedTile();
        }
    }
}
PowerBITileEmbedComponent.decorators = [
    { type: Component, args: [{
                selector: 'powerbi-tile[embedConfig]',
                template: '<div class={{cssClassName}} #tileContainer></div>'
            },] }
];
PowerBITileEmbedComponent.ctorParameters = () => [];
PowerBITileEmbedComponent.propDecorators = {
    embedConfig: [{ type: Input }],
    eventHandlers: [{ type: Input }],
    containerRef: [{ type: ViewChild, args: ['tileContainer',] }]
};

// Copyright (c) Microsoft Corporation.
/**
 * Paginated report component to embed the entity, extends the Base component
 */
class PowerBIPaginatedReportEmbedComponent extends PowerBIEmbedComponent {
    constructor() {
        super();
    }
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            const prevEmbedConfig = changes.embedConfig.previousValue;
            // Check if the function is being called for the first time
            if (!prevEmbedConfig) {
                return;
            }
            // Input from parent get updated, thus call embedOrUpdateDashboard function
            this.embedOrUpdatedPaginatedReport(prevEmbedConfig);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed
            this.embedPaginatedReport();
        }
    }
    /**
     * Embed the PowerBI Paginated report
     *
     * @returns void
     */
    embedPaginatedReport() {
        // Check if the HTML container is rendered and available
        if (!this.containerRef.nativeElement) {
            return;
        }
        // Embed paginated report
        this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
    }
    /**
     * When component updates, choose to _embed_ the powerbi paginated report
     * or do nothing if the embedUrl and accessToken did not update in the new properties
     *
     * @param prevEmbedConfig IEmbedConfiguration
     * @returns void
     */
    embedOrUpdatedPaginatedReport(prevEmbedConfig) {
        // Check if Embed URL and Access Token are present in current properties
        if (!this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
            return;
        }
        // Embed in the following scenario
        // Embed URL is updated (E.g. New paginated report is to be embedded)
        if (this.containerRef.nativeElement && this.embedConfig.embedUrl !== prevEmbedConfig.embedUrl) {
            this.embedPaginatedReport();
        }
    }
}
PowerBIPaginatedReportEmbedComponent.decorators = [
    { type: Component, args: [{
                selector: 'powerbi-paginated-report[embedConfig]',
                template: '<div class={{cssClassName}} #paginatedReportContainer></div>'
            },] }
];
PowerBIPaginatedReportEmbedComponent.ctorParameters = () => [];
PowerBIPaginatedReportEmbedComponent.propDecorators = {
    embedConfig: [{ type: Input }],
    containerRef: [{ type: ViewChild, args: ['paginatedReportContainer',] }]
};

// Copyright (c) Microsoft Corporation.
/**
 * Visual component to embed the visual, extends Base component
 */
class PowerBIVisualEmbedComponent extends PowerBIEmbedComponent {
    constructor() {
        super();
    }
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    // Returns embed object to calling function
    getVisual() {
        return this._embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            const prevEmbedConfig = changes.embedConfig.previousValue;
            // Check if the function is being called for the first time
            if (!prevEmbedConfig) {
                return;
            }
            // Input from parent get updated, thus call embedOrUpdateDashboard function
            this.embedOrUpdateVisual(prevEmbedConfig);
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed or bootstrap
            if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                this.embedVisual();
            }
            else {
                this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed the PowerBI Visual
     *
     * @returns void
     */
    embedVisual() {
        // Check if the HTML container is rendered and available
        if (!this.containerRef.nativeElement) {
            return;
        }
        this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
    }
    /**
     * When component updates, choose to _embed_ the powerbi visual
     * or do nothing if the embedUrl and accessToken did not update in the new properties
     *
     * @param prevEmbedConfig IVisualEmbedConfiguration
     * @returns void
     */
    embedOrUpdateVisual(prevEmbedConfig) {
        // Check if Embed URL and Access Token are present in current properties
        if (!this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
            return;
        }
        // Embed in the following scenario
        // Embed URL is updated (E.g. New visual is to be embedded)
        if (this.containerRef.nativeElement && this.embedConfig.embedUrl !== prevEmbedConfig.embedUrl) {
            this.embedVisual();
        }
    }
}
PowerBIVisualEmbedComponent.decorators = [
    { type: Component, args: [{
                selector: 'powerbi-visual[embedConfig]',
                template: '<div class={{cssClassName}} #visualContainer></div>'
            },] }
];
PowerBIVisualEmbedComponent.ctorParameters = () => [];
PowerBIVisualEmbedComponent.propDecorators = {
    embedConfig: [{ type: Input }],
    eventHandlers: [{ type: Input }],
    containerRef: [{ type: ViewChild, args: ['visualContainer',] }]
};

// Copyright (c) Microsoft Corporation.
/**
 * Qna component to embed the Qna visual, extends Base component
 */
class PowerBIQnaEmbedComponent extends PowerBIEmbedComponent {
    constructor() {
        super();
    }
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    // Returns embed object to calling function
    getQna() {
        return this._embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            const prevEmbedConfig = changes.embedConfig.previousValue;
            // Check if the function is being called for the first time
            if (!prevEmbedConfig) {
                return;
            }
            // Input from parent get updated, thus call embedOrUpdateDashboard function
            this.embedOrUpdateQna(prevEmbedConfig);
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed or bootstrap
            if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                this.embedQnaVisual();
            }
            else {
                this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed the PowerBI QnA Visual
     *
     * @returns void
     */
    embedQnaVisual() {
        // Check if the HTML container is rendered and available
        if (!this.containerRef.nativeElement) {
            return;
        }
        this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
    }
    /**
     * When component updates, choose to _embed_ the powerbi qna visual
     * or do nothing if the embedUrl and accessToken did not update in the new properties
     *
     * @param prevEmbedConfig IQnaEmbedConfiguration
     * @returns void
     */
    embedOrUpdateQna(prevEmbedConfig) {
        // Check if Embed URL and Access Token are present in current properties
        if (!this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
            return;
        }
        // Embed in the following scenario
        // Embed URL is updated (E.g. New Qna visual is to be embedded)
        if (this.containerRef.nativeElement && this.embedConfig.embedUrl !== prevEmbedConfig.embedUrl) {
            this.embedQnaVisual();
        }
    }
}
PowerBIQnaEmbedComponent.decorators = [
    { type: Component, args: [{
                selector: 'powerbi-qna[embedConfig]',
                template: '<div class={{cssClassName}} #qnaContainer></div>'
            },] }
];
PowerBIQnaEmbedComponent.ctorParameters = () => [];
PowerBIQnaEmbedComponent.propDecorators = {
    embedConfig: [{ type: Input }],
    eventHandlers: [{ type: Input }],
    containerRef: [{ type: ViewChild, args: ['qnaContainer',] }]
};

// Copyright (c) Microsoft Corporation.
class PowerBIEmbedModule {
}
PowerBIEmbedModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PowerBIEmbedComponent,
                    PowerBIDashboardEmbedComponent,
                    PowerBIPaginatedReportEmbedComponent,
                    PowerBIQnaEmbedComponent,
                    PowerBIReportEmbedComponent,
                    PowerBITileEmbedComponent,
                    PowerBIVisualEmbedComponent,
                ],
                imports: [],
                exports: [
                    PowerBIDashboardEmbedComponent,
                    PowerBIPaginatedReportEmbedComponent,
                    PowerBIQnaEmbedComponent,
                    PowerBIReportEmbedComponent,
                    PowerBITileEmbedComponent,
                    PowerBIVisualEmbedComponent,
                ],
            },] }
];

// Copyright (c) Microsoft Corporation.

/**
 * Generated bundle index. Do not edit.
 */

export { PowerBIDashboardEmbedComponent, PowerBIEmbedModule, PowerBIPaginatedReportEmbedComponent, PowerBIQnaEmbedComponent, PowerBIReportEmbedComponent, PowerBITileEmbedComponent, PowerBIVisualEmbedComponent, PowerBIEmbedComponent as ɵa };
//# sourceMappingURL=powerbi-client-angular.js.map
